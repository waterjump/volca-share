VS.BassEmulator = function() {
  // =====================
  // Declare map constants
  // =====================

  const keyMap = {
    65: 130.81, // C
    87: 138.59, // C#
    83: 146.83, // D
    69: 155.56, // D#
    68: 164.81, // E
    70: 174.61, // F
    84: 185.00, // F#
    71: 196.00, // G
    89: 207.65, // G#
    72: 220.00, // A
    85: 233.08, // A#
    74: 246.94, // B
    75: 261.63, // C
    79: 277.18, // C#
    76: 293.66  // D
  }

  // Key is vco pitch MIDI value.  Value is detune value in semitones.
  const pitchMap = {
     0: -12,    1: -12,    2: -11,    3: -10,    4: -9,     5: -8,     6: -7,     7: -6,     8: -5,     9: -4,
    10: -3,    11: -2,    12: -1,    13: -0.96, 14: -0.92, 15: -0.88, 16: -0.84, 17: -0.80, 18: -0.78, 19: -0.76,
    20: -0.74, 21: -0.72, 22: -0.70, 23: -0.68, 24: -0.66, 25: -0.64, 26: -0.62, 27: -0.60, 28: -0.58, 29: -0.56,
    30: -0.54, 31: -0.52, 32: -0.50, 33: -0.48, 34: -0.46, 35: -0.44, 36: -0.42, 37: -0.40, 38: -0.38, 39: -0.36,
    40: -0.34, 41: -0.32, 42: -0.30, 43: -0.28, 44: -0.26, 45: -0.24, 46: -0.22, 47: -0.20, 48: -0.18, 49: -0.16,
    50: -0.14, 51: -0.12, 52: -0.10, 53: -0.08, 54: -0.06, 55: -0.04, 56: -0.02, 57: 0,     58: 0,     59: 0,
    60: 0,     61: 0,     62: 0,     63: 0,     64: 0,     65: 0,     66: 0,     67: 0,     68: 0,     69: 0,
    70: 0,     71: 0.02,  72: 0.04,  73: 0.06,  74: 0.08,  75: 0.10,  76: 0.12,  77: 0.14,  78: 0.16,  79: 0.18,
    80: 0.20,  81: 0.22,  82: 0.24,  83: 0.26,  84: 0.28,  85: 0.30,  86: 0.32,  87: 0.34,  88: 0.36,  89: 0.38,
    90: 0.40,  91: 0.42,  92: 0.44,  93: 0.46,  94: 0.48,  95: 0.50,  96: 0.52,  97: 0.54,  98: 0.56,  99: 0.58,
    100: 0.60, 101: 0.62, 102: 0.64, 103: 0.66, 104: 0.68, 105: 0.70, 106: 0.72, 107: 0.74, 108: 0.76, 109: 0.78,
    110: 0.80, 111: 0.84, 112: 0.88, 113: 0.92, 114: 0.96, 115: 1,    116: 2,    117: 3,    118: 4,    119: 5,
    120: 6,    121: 7,    122: 8,    123: 9,    124: 10,   125: 11,   126: 12,   127: 12
  }

  const zKeyCode = 90;
  const xKeyCode = 88;

  const octaveMap = {
    "-1": { displayNumber: 8, frequencyFactor: 0.0625 },
    0: { displayNumber: 9, frequencyFactor: 0.125 },
    1: { displayNumber: 21, frequencyFactor: 0.25 },
    2: { displayNumber: 33, frequencyFactor: 0.5 },
    3: { displayNumber: 45, frequencyFactor: 1 },
    4: { displayNumber: 57, frequencyFactor: 2 },
    5: { displayNumber: 69, frequencyFactor: 4 },
    6: { displayNumber: 81, frequencyFactor: 8 },
    7: { displayNumber: 93, frequencyFactor: 16 },
    8: { displayNumber: 105, frequencyFactor: 32 },
    9: { displayNumber: 118, frequencyFactor: 64 }
  };

  const octaveKnobMidiMap = {
    '-1': 0,
    0: 0,
    1: 0,
    2: 33,
    3: 55,
    4: 77,
    5: 99,
    6: 127,
    7: 127,
    8: 127,
    9: 127
  };

  const keyCodes = Object.keys(keyMap).map(Number);

  const parameterMaps = {
    decayReleaseMap: {
      0: 0.07, 10: 0.075, 20: 0.085, 30: 0.091, 40: 0.1, 50: 0.11, 60: 0.13,
      70: 0.15, 80: 0.18, 90: 0.215, 100: 0.29, 110: 0.44, 115: 0.56, 120: 0.84,
      122: 1.04, 125: 1.65, 127: 2.64
    },
    lfoRateMap: {
      0: 0.0383, 10: 0.23, 20: 0.421, 30: 0.612, 40: 0.803, 50: 1, 60: 1.186,
      70: 1.377, 80: 1.569, 90: 1.757, 100: 6.757, 110: 20, 115: 35.71,
      120: 60, 127: 94
    }
  };

  const decayReleaseGainCurve = [
    1, 0.89, 0.8, 0.73, 0.65, 0.58, 0.52, 0.46, 0.41, 0.36, 0.31, 0.26, 0.22,
    0.18, 0.15, 0.12, 0.09, 0.07, 0.05, 0.03, 0.02, 0.01, 0.005, 0.0001
  ];

  const calculateMappedParameter = function(paramName, midiValue) {
    let entries, midi, paramValue, lowerMidi, lowerParamValue, slope;
    let midiDifference, rawValue, cleanValue;
    let map = parameterMaps[`${paramName}Map`];

    midiValue = Math.round(midiValue);

    if (map[midiValue] !== undefined) {
      return map[midiValue];
    } else {
      entries =
        Object.keys(map).map((key) => [key, map[key]]);

      for (let index = 0; index < entries.length; index++) {
        midi = entries[index][0];
        if (midiValue < midi) {
          paramValue = entries[index][1];
          lowerMidi = entries[index - 1][0];
          lowerParamValue = entries[index - 1][1];
          slope =
            (paramValue - lowerParamValue) /
              (parseFloat(midi) - parseFloat(lowerMidi));
          midiDifference = midiValue - lowerMidi;
          rawValue = (midiDifference * slope) + lowerParamValue;
          cleanValue = Number(rawValue.toFixed(3));

          map[Number(midiValue)] = cleanValue;
          return cleanValue;
        }
      }
    }
  };


  // ===========================================
  // Setup patch object to hold parameter values
  // ===========================================

  const defaultVcoAmp = 0.33;

  const patch = {
    envelope: { attack: 0, decayRelease: 0.07, cutoffEgInt: 0 },
    filterEgCoefficient: 1.35,
    octave: 3,
    filter: { cutoff: 20000, peak: 0 },
    lfo: {
      shape: 'triangle',
      targetAmp: false,
      targetPitch: false,
      targetCutoff: true,
      ampValue: 0,
      pitchValue: 0,
      cutoffValue: 0,
      frequency: 0.1
    },
    vco:
      [
        null,
        { shape: 'sawtooth', amp: defaultVcoAmp, pitchMidi: 63, frequency: 440, detune: 0 },
        { shape: 'sawtooth', amp: defaultVcoAmp, pitchMidi: 63, frequency: 440, detune: 0 },
        { shape: 'square', amp: defaultVcoAmp, pitchMidi: 63, frequency: 440, detune: 0 }
      ],
    sustainOn: false,
    ampEgOn: false,
    volume: 1,

    getPercentage: function(midiValue) {
      return midiValue / 127.0;
    },
    setattack: function(midiValue) {
      // Based on collected data from Volca Bass
      this.envelope.attack = this.getPercentage(midiValue) * 0.86;
    },
    setdecay_release: function(midiValue) {
      // Keeping these old formulas bc I might do a before and after.
      // let oldValue = 5 * this.getPercentage(midiValue)**3 + 0.05;
      this.envelope.decayRelease =
        calculateMappedParameter('decayRelease', midiValue);
    },
    setcutoff_eg_int: function(midiValue) {
      // let oldValueInHz = this.getPercentage(midiValue)**2 * 10000;
      // TODO: This needs adjusting.  NOTE: It's in cents now.  Not Hz.
      this.envelope.cutoffEgInt = 1200 * (midiValue / 20.0);
    },
    setoctave: function(midiValue) {
      this.octave = parseInt(VS.display.octaveString(midiValue)[3]);
    },
    setpeak: function(midiValue) {
      this.filter.peak = (this.getPercentage(midiValue)**2.5 * 30.0);
    },
    setcutoff: function(midiValue) {
      // Note: Curve calculated using audacity data from actual synth, and
      //   plugged into WolframAlpha: https://tinyurl.com/y2qp9ebp
      this.filter.cutoff = 3.28311 * (Math.E**(0.0802801 * midiValue))
    },
    setlfo_rate: function(midiValue) {
      // let oldValue = (this.getPercentage(midiValue)**3 * 35) + 0.1;
      this.lfo.frequency = calculateMappedParameter('lfoRate', midiValue);
    },
    setlfo_int: function(midiValue) {
      percentage = this.getPercentage(midiValue);
      this.lfo.pitchValue = percentage * 900;
      this.lfo.cutoffValue = percentage**2 * 4800;
      this.lfo.ampValue = percentage;
    },
    setvco_pitch: function(oscNumber, midiValue) {
      this.vco[oscNumber].pitchMidi = midiValue;
      this.vco[oscNumber].detune = pitchMap[patch.vco[oscNumber].pitchMidi] * 100;
    },
    setvco1_pitch: function(midiValue) {
      this.setvco_pitch(1, midiValue);
    },
    setvco2_pitch: function(midiValue) {
      this.setvco_pitch(2, midiValue);
    },
    setvco3_pitch: function(midiValue) {
      this.setvco_pitch(3, midiValue);
    },
    setvco_active: function(oscNumber, value) {
      if (value === 'true') {
        this.vco[oscNumber].amp = defaultVcoAmp;
      } else {
        this.vco[oscNumber].amp = 0;
      }
    },
    setvco1_active: function(value) {
      this.setvco_active(1, value);
    },
    setvco2_active: function(value) {
      this.setvco_active(2, value);
    },
    setvco3_active: function(value) {
      this.setvco_active(3, value);
    },
    setvolume: function(value) {
      this.volume = this.getPercentage(value);
    },
    setlfo_target_amp: function(value) {
      this.lfo.targetAmp = (value === 'true');
    },
    setlfo_target_pitch: function(value) {
      this.lfo.targetPitch = (value === 'true');
    },
    setlfo_target_cutoff: function(value) {
      this.lfo.targetCutoff = (value === 'true');
    },
    setlfo_wave: function(shape) {
      this.lfo.shape = shape;
    },
    setvco1_wave: function(shape) {
      this.vco[1].shape = shape;
    },
    setvco2_wave: function(shape) {
      this.vco[2].shape = shape;
    },
    setvco3_wave: function(shape) {
      this.vco[3].shape = shape;
    },
    setsustain_on: function(value) {
      this.sustainOn = (value === 'true');
    },
    setamp_eg_on: function(value) {
      this.ampEgOn = (value === 'true');
    }
  };

  const volcaInterface = {
    lightAndCheck: function(paramName) {
      let light = $(`#${paramName}_light`);
      let checkbox = $(`input#patch_${paramName}`)
      if (!(light.hasClass('lit'))) { light.toggleClass('lit') }
      if (!(checkbox.prop('checked'))) { checkbox.prop('checked', true) }
    },
    unlightAndUncheck: function(paramName) {
      let light = $(`#${paramName}_light`);
      let checkbox = $(`input#patch_${paramName}`)
      if (light.hasClass('lit')) { light.toggleClass('lit') }
      if (checkbox.prop('checked')) { checkbox.prop('checked', false) }
    }
  }

  // TODO: Put this in a class?
  // ==============================
  // Accept query string parameters
  // ==============================
  const urlParams = {
    get: function(name) {
      name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
      var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
      var results = regex.exec(location.search);
      return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }
  };

  // TODO: Switch to URLSearchParams when I find a web driver that supports it.
  // let urlParams = new URLSearchParams(window.location.search);

  qsKnobs = [
    'attack', 'decay_release', 'cutoff_eg_int', 'octave', 'peak', 'cutoff',
    'lfo_rate', 'lfo_int', 'vco1_pitch','vco2_pitch', 'vco3_pitch', 'volume'
  ];

  qsKnobs.forEach(function(qsParam) {
    let rawValue = urlParams.get(qsParam);
    let parsedValue = parseInt(rawValue);
    if ( 0 <= parsedValue && parsedValue <= 127) {
      patch[`set${qsParam}`](parsedValue);

      new VS.Knob($(`#${qsParam}`)).setKnob(parsedValue);
    } else {
      new VS.Knob($(`#${qsParam}`)).setKnob();
    }
  });

  let qsVcoActiveParams = ['vco1_active', 'vco2_active', 'vco3_active'];

  qsVcoActiveParams.forEach(function(qsParam) {
    let rawValue = urlParams.get(qsParam);
    if (['true', 'false'].indexOf(rawValue) !== -1) {
      patch[`set${qsParam}`](rawValue);

      // NOTE: Might be able to trigger the event in form.es6 if it differs
      //   from default.  That way the data attributes and css classes will
      //   be handled there and I can removed a lot of this stuff.  Maybe.
      let button = $(`#${qsParam}_button`);
      let vcoKnob = function() {
        let number = qsParam.charAt(3);
        return $(`#vco${number}_pitch`);
      }();

      button.data('active', (rawValue === 'true'));

      if (rawValue === 'true') {
        if (!(button.hasClass('lit'))) { button.toggleClass('lit') }
        if (!(vcoKnob.hasClass('lit'))) { vcoKnob.toggleClass('lit') }
        if (vcoKnob.hasClass('unlit')) { vcoKnob.toggleClass('unlit') }
      } else {
        if (button.hasClass('lit')) { button.toggleClass('lit') }
        if (vcoKnob.hasClass('lit')) { vcoKnob.toggleClass('lit') }
        if (!(vcoKnob.hasClass('unlit'))) { vcoKnob.toggleClass('unlit') }
      }
    }
  });


  let qsBooleanParameters = [
    'lfo_target_amp', 'lfo_target_pitch', 'lfo_target_cutoff', 'sustain_on',
    'amp_eg_on'
  ];
  qsBooleanParameters.forEach(function(qsParam) {
    let rawValue = urlParams.get(qsParam);
    if (['true', 'false'].indexOf(rawValue) !== -1) {
      patch[`set${qsParam}`](rawValue);

      if (rawValue === 'true') {
        volcaInterface.lightAndCheck(qsParam);
      } else {
        volcaInterface.unlightAndUncheck(qsParam);
      }
    }
  });

  // LFO wave from query string
  let rawValue = urlParams.get('lfo_wave');
  if (['triangle', 'square'].indexOf(rawValue) !== -1) {
    patch.setlfo_wave(rawValue);

    if (rawValue == 'square') {
      volcaInterface.lightAndCheck('lfo_wave');
    } else {
      volcaInterface.unlightAndUncheck('lfo_wave');
    }
  }

  let vcoGroupParam = urlParams.get('vco_group');
  if (['one', 'two', 'three'].indexOf(vcoGroupParam) !== -1) {
    // TODO: Set vco group on patch object when it is supported

    $('.light[data-radio]').each(function() {
      $(this).removeClass('lit');
      $(`:radio[value=${vcoGroupParam}]`).prop('checked', false);
    });
    $(`:radio[value=${vcoGroupParam}]`).prop('checked', true);
    $(`label[for="patch_vco_group_${vcoGroupParam}"]`).find('span .light').addClass('lit');
  }

  qsVcoWaves = ['vco1_wave', 'vco2_wave', 'vco3_wave'];

  qsVcoWaves.forEach(function(qsParam) {
    let rawValue = urlParams.get(qsParam);

    if (['square', 'sawtooth'].indexOf(rawValue) !== -1) {
      patch[`set${qsParam}`](rawValue);

      if (rawValue == 'square') {
        volcaInterface.lightAndCheck(qsParam);
      } else {
        volcaInterface.unlightAndUncheck(qsParam);
      }
    }
  });

  // =======================
  // END query string params
  // =======================

  let notePlaying;
  let keysDown = [];
  const builtInDecay = 0.1;

  // NOTE: Exclude audio context stuff in tests because Poltergeist will
  //  error out on it.  :-[  FIXME.
  <% if !Rails.env.test? %>
  // =====================================
  // Setup web audio nodes (from here down)
  // =====================================

  const audioCtx = new AudioContext();

  let masterAmp = audioCtx.createGain();
  masterAmp.connect(audioCtx.destination);

  // An amp used for modulating amplitude without overriding
  //  the master Amp level
  let preAmp = audioCtx.createGain();
  preAmp.connect(masterAmp);

  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.setValueAtTime(patch.filter.cutoff, audioCtx.currentTime);
  filter.Q.value = patch.filter.peak;
  filter.connect(preAmp);

  const filterEgAmp = audioCtx.createGain();
  filterEgAmp.gain.setValueAtTime(patch.envelope.cutoffEgInt, audioCtx.currentTime);
  filterEgAmp.connect(filter.detune);

  const envelope = audioCtx.createConstantSource();
  envelope.offset.setValueAtTime(0.0001, audioCtx.currentTime);
  envelope.connect(filterEgAmp);
  envelope.start();

  // Oscillator mute button amps (will go to gain 0 on mute button click)
  let osc1MuteAmp = audioCtx.createGain()
  osc1MuteAmp.gain.value = patch.vco[1].amp;
  osc1MuteAmp.connect(filter);
  let osc2MuteAmp = audioCtx.createGain()
  osc2MuteAmp.gain.value = patch.vco[2].amp;
  osc2MuteAmp.connect(filter);
  let osc3MuteAmp = audioCtx.createGain()
  osc3MuteAmp.gain.value = patch.vco[3].amp;
  osc3MuteAmp.connect(filter);

  const oscMuteAmps = [null, osc1MuteAmp, osc2MuteAmp, osc3MuteAmp];

  // Oscillator note amps (will go to gain 0 on note off)
  let osc1NoteAmp = audioCtx.createGain()
  osc1NoteAmp.gain.value = 0.0001;
  osc1NoteAmp.connect(oscMuteAmps[1]);
  let osc2NoteAmp = audioCtx.createGain()
  osc2NoteAmp.gain.value = 0.0001;
  osc2NoteAmp.connect(oscMuteAmps[2]);
  let osc3NoteAmp = audioCtx.createGain()
  osc3NoteAmp.gain.value = 0.0001;
  osc3NoteAmp.connect(oscMuteAmps[3]);

  const oscNoteAmps = [null, osc1NoteAmp, osc2NoteAmp, osc3NoteAmp];

  let osc = [null, null, null, null];

  const ampLfoPitch = audioCtx.createGain()
  const setAmpLfoPitchGain = function() {
    if (patch.lfo.targetPitch) {
      // Affect pitch
      ampLfoPitch.gain.setValueAtTime(patch.lfo.pitchValue, audioCtx.currentTime);
    } else {
      // Do not affect pitch
      ampLfoPitch.gain.setValueAtTime(0, audioCtx.currentTime);
    }
  }
  setAmpLfoPitchGain();

  const ampLfoCutoff = audioCtx.createGain()
  const setAmpLfoCutoffGain = function() {
    if (patch.lfo.targetCutoff) {
      // Affect filter cutoff
      ampLfoCutoff.gain.setValueAtTime(patch.lfo.cutoffValue, audioCtx.currentTime);
    } else {
      // Do not affect filter cutoff
      ampLfoCutoff.gain.setValueAtTime(0, audioCtx.currentTime);
    }
  }
  setAmpLfoCutoffGain();
  ampLfoCutoff.connect(filter.detune);

  // Creates a curve that goes from -1, -1 to 1, 0.
  const makeLfoAmpCurve = function() {
    let n_samples = 44100;
    let curve = new Float32Array(n_samples)
    let i = 0;
    for ( ; i < n_samples; ++i ) {
      curve[i] = i / (n_samples - 1) - 1;
    }
    return curve;
  };

  const lfoAmpWaveShaper = audioCtx.createWaveShaper();
  lfoAmpWaveShaper.curve = makeLfoAmpCurve();

  const ampLfoAmp = audioCtx.createGain()
  const setAmpLfoAmpGain = function() {
    if (patch.lfo.targetAmp) {
      // Affect amp
      ampLfoAmp.gain.setValueAtTime(patch.lfo.ampValue, audioCtx.currentTime);
    } else {
      // Do not affect amp
      ampLfoAmp.gain.setValueAtTime(0, audioCtx.currentTime);
    }
  }
  setAmpLfoAmpGain();

  lfoAmpWaveShaper.connect(ampLfoAmp);
  ampLfoAmp.connect(preAmp.gain);

  let oscLfo;

  const setupOscLfo = function() {
    oscLfo = audioCtx.createOscillator();
    oscLfo.type = patch.lfo.shape;
    oscLfo.frequency.setValueAtTime(patch.lfo.frequency, audioCtx.currentTime);
    oscLfo.connect(ampLfoPitch);
    oscLfo.connect(ampLfoCutoff);
    oscLfo.connect(lfoAmpWaveShaper);
    oscLfo.start();
  }

  setupOscLfo();

  // Setup oscilators
  [1, 2, 3].forEach(function(oscNumber) {
    let oscillator = audioCtx.createOscillator();
    oscillator.type = patch.vco[oscNumber].shape;
    oscillator.detune.setValueAtTime(
      patch.vco[oscNumber].detune,
      audioCtx.currentTime
    );

    oscillator.frequency.setValueAtTime(
      patch.vco[oscNumber].frequency,
      audioCtx.currentTime
    );

    osc[oscNumber] = oscillator;
    osc[oscNumber].connect(oscNoteAmps[oscNumber]);
    ampLfoPitch.connect(osc[oscNumber].detune);
    osc[oscNumber].start();
  });

  // ==========================
  //  get browser capabilities
  // ==========================
  const browserFeatures = {};

  const checkCustomCurveClearing = function() {
    let dummyGain = audioCtx.createGain();
    dummyGain.gain.setValueCurveAtTime([0, 0.5, 0], audioCtx.currentTime, 2.6);
    try {
      dummyGain.gain.cancelScheduledValues(audioCtx.currentTime + 0.1);
      dummyGain.gain.setValueAtTime(1, audioCtx.currentTime + 0.2);
      browserFeatures['customCurveClearing'] = true;
    } catch (error) {
      browserFeatures['customCurveClearing'] = false;
    }
  }

  const testBrowserFeatures = function() {
    checkCustomCurveClearing();
    console.log(browserFeatures);
  }

  testBrowserFeatures();

  // END get browser capabilities


  const triggerDecay = function() {
    envelope.offset.linearRampToValueAtTime(
      0.0001,
      attackEndTime + (patch.envelope.decayRelease * patch.filterEgCoefficient)
    );

    if (patch.ampEgOn) {
      oscNoteAmps.forEach(function(oscNoteAmp){
        if (oscNoteAmp !== null) {
          oscNoteAmp.gain.setValueAtTime(1, attackEndTime);

          if (browserFeatures['customCurveClearing']) {
            // use custom curve
            oscNoteAmp.gain.setValueCurveAtTime(
              decayReleaseGainCurve,
              attackEndTime,
              patch.envelope.decayRelease
            )
          } else {
            oscNoteAmp.gain.linearRampToValueAtTime(
              0.0001,
              attackEndTime + patch.envelope.decayRelease
            )
          }
        }
      });
    }
  };

  const retriggerLfo = function() {
    let lfo = patch.lfo;
    if (lfo.shape !== 'square') { return; }
    if (!(lfo.targetAmp) && !(lfo.targetPitch) && !(lfo.targetCutoff)) { return; }
    if (lfo.ampValue + lfo.pitchValue + lfo.cutoffValue === 0) { return; }

    oscLfo.disconnect();
    oscLfo = null;
    setupOscLfo();
  };

  let lastAttackStart;
  let attackEndTime;

  const playNewNote = function() {
    time = audioCtx.currentTime;

    envelope.offset.cancelScheduledValues(0);
    envelope.offset.setValueAtTime(0.0001, time);

    lastAttackStart = time;
    attackEndTime = time + patch.envelope.attack;

    // VCOs 1, 2, and 3
    [1, 2, 3].forEach(function(oscNumber) {
      oscNoteAmps[oscNumber].gain.cancelScheduledValues(time);

      patch.vco[oscNumber].lastFrequency = patch.vco[oscNumber].frequency;
      patch.vco[oscNumber].frequency =
        keyMap[notePlaying] *
        octaveMap[patch.octave].frequencyFactor;

      osc[oscNumber].frequency.setValueAtTime(
        patch.vco[oscNumber].frequency,
        time
      );

      if (patch.ampEgOn && patch.envelope.attack > 0) {
        oscNoteAmps[oscNumber].gain.setValueAtTime(0, time);
        oscNoteAmps[oscNumber].gain.linearRampToValueAtTime(1, attackEndTime);
      } else {
        oscNoteAmps[oscNumber].gain.setValueAtTime(1, time);
      }
    });

    retriggerLfo();

    // Retrigger envelope
    // Attack
    envelope.offset.linearRampToValueAtTime(1, attackEndTime);

    // Decay
    if (!patch.sustainOn) {
      triggerDecay();
    }
  };

  const changeCurrentNote = function() {
    [1, 2, 3].forEach(function(oscNumber) {
      patch.vco[oscNumber].lastFrequency = patch.vco[oscNumber].frequency;
      patch.vco[oscNumber].frequency =
        keyMap[notePlaying] *
        octaveMap[patch.octave].frequencyFactor;

      osc[oscNumber].frequency.setValueAtTime(
        patch.vco[oscNumber].lastFrequency, audioCtx.currentTime
      );
      osc[oscNumber].frequency.linearRampToValueAtTime(
        patch.vco[oscNumber].frequency, audioCtx.currentTime + 0.05
      );
    });
  };

  const changeOctave = function() {
    VS.display.update(octaveMap[patch.octave].displayNumber, 'noteString');

    // Turn octave knob
    new VS.Knob($('#octave')).setKnob(octaveKnobMidiMap[patch.octave]);

    if (notePlaying === undefined) { return; } // at init time

    if (keysDown.length === 0) { return; } // when it's amp_eg release

    osc.forEach(function(oscillator, oscNumber) {
      if (oscillator !== null) {
        patch.vco[oscNumber].frequency =
          keyMap[notePlaying] *
          octaveMap[patch.octave].frequencyFactor;

        osc[oscNumber].frequency.setValueAtTime(
          patch.vco[oscNumber].frequency, audioCtx.currentTime
        );
      }
    });
  }
  changeOctave();

  const keyboardDown = function(){
    keysDown.push(notePlaying);

    if (keysDown.length === 1) {
      playNewNote();
    } else {
      changeCurrentNote();
    }
  };

  const keyboardUp = function() {
    let currentValue;
    let time = audioCtx.currentTime;
    let gainCurve = decayReleaseGainCurve;
    let duration = patch.envelope.decayRelease;

    if (patch.ampEgOn) {
      if (time < attackEndTime || patch.sustainOn) {

        // filter envelope
        try {
          envelope.offset.cancelAndHoldAtTime(time);
          currentValue = envelope.offset.value;
        } catch (error) {
          // Firefox doesn't support cancelAndHoldAtTime();
          // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/cancelAndHoldAtTime
          currentValue = envelope.offset.value;
          envelope.offset.cancelScheduledValues(time);
          envelope.offset.setValueAtTime(currentValue, time);
        }
        // TODO: Use custom curve for filter?
        envelope.offset.linearRampToValueAtTime(
          0.0001,
          time + (patch.envelope.decayRelease * patch.filterEgCoefficient * currentValue)
        );

        // Amp eg
        oscNoteAmps.forEach(function(oscNoteAmp) {
          if (oscNoteAmp !== null) {
            try {
              oscNoteAmp.gain.cancelAndHoldAtTime(time);
              currentValue = oscNoteAmp.gain.value; // Always between 0 and 1
            } catch (error) {
              // Firefox doesn't support cancelAndHoldAtTime();
              // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/cancelAndHoldAtTime
              currentValue = oscNoteAmp.gain.value; // Always between 0 and 1
              oscNoteAmp.gain.cancelScheduledValues(time);
              oscNoteAmp.gain.setValueAtTime(currentValue, time);
            }

            duration = currentValue * patch.envelope.decayRelease;

            if (browserFeatures['customCurveClearing']) {
              // adjust gain curve
              gainCurve = decayReleaseGainCurve.map(
                function(value) { return value * currentValue }
              );
              oscNoteAmp.gain.setValueCurveAtTime(gainCurve, time, duration);
            } else {
              oscNoteAmp.gain.linearRampToValueAtTime(0.0001, time + duration);
            }
          }
        });
      }

    } else {
      // Filter cutoff down immediately
      envelope.offset.cancelScheduledValues(time);
      envelope.offset.setValueAtTime(0.0001, time);

      // Turn amp down immediately
      oscNoteAmps.forEach(function(oscNoteAmp) {
        if (oscNoteAmp !== null) {
          oscNoteAmp.gain.setTargetAtTime(0.0001, time, builtInDecay / 3);
        }
      });
    }
  };

  window.onkeydown = function(keyDown) {
    // PLAY NOTES
    if (keyCodes.includes(keyDown.keyCode)) {
      notePlaying = keyDown.keyCode;

      keyboardDown();
    }

    // CHANGE OCTAVE
    if ([zKeyCode, xKeyCode].includes(keyDown.keyCode)) {
      if (keyDown.keyCode == zKeyCode && patch.octave > -1) {
        patch.octave -= 1;
      }
      if (keyDown.keyCode == xKeyCode && patch.octave < 9) {
        patch.octave += 1;
      }
      changeOctave();
    }
  };

  window.onkeyup = function(keyUp) {
    keysDown = keysDown.filter(key => key !== keyUp.keyCode);

    if (keysDown.length > 0) {
      notePlaying = keysDown[keysDown.length - 1];

      changeCurrentNote();

      return;
    }

    keyboardUp();
  };

  $(document).on('mousemove touchmove', function(e) {
    if (VS.activeKnob === null) { return; }
    if (VS.dragging === false) { return; }
    let midiValue, percentage;

    // NOTE:  Could probably DRY up these if blocks for each
    //   knob into a single block.

    // EG ATTACK
    if (VS.activeKnob.element.id == 'attack') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setattack(midiValue);
    }

    // EG DECAY/RELEASE
    if (VS.activeKnob.element.id == 'decay_release') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setdecay_release(midiValue);
    }

    // CUTOFF EG INT
    if (VS.activeKnob.element.id == 'cutoff_eg_int') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setcutoff_eg_int(midiValue);

      filterEgAmp.gain.setValueAtTime(
        patch.envelope.cutoffEgInt,
        audioCtx.currentTime
      );
    }

    // TODO: Change octave when octave knob is turn via interface

    // FILTER PEAK (RESONANCE)
    if (VS.activeKnob.element.id == 'peak') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setpeak(midiValue);

      filter.Q.value = patch.filter.peak;
    }

    // FILTER CUTOFF
    if (VS.activeKnob.element.id == 'cutoff') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setcutoff(midiValue);

      filter.frequency.setValueAtTime(patch.filter.cutoff, audioCtx.currentTime);
    }

    // LFO RATE
    if (VS.activeKnob.element.id == 'lfo_rate') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setlfo_rate(midiValue);

      oscLfo.frequency.setValueAtTime(patch.lfo.frequency, audioCtx.currentTime);
    }

    // LFO INT
    if (VS.activeKnob.element.id == 'lfo_int') {
      midiValue = $(VS.activeKnob.element).data('trueMidi');
      if (midiValue == undefined) { return; }

      patch.setlfo_int(midiValue);

      // TODO: Think about calling setAmpLfoPitchGain() here maybe.  And for others.
      if (patch.lfo.targetPitch) {
        ampLfoPitch.gain.setValueAtTime(patch.lfo.pitchValue, audioCtx.currentTime);
      }

      if (patch.lfo.targetCutoff) {
        ampLfoCutoff.gain.setValueAtTime(patch.lfo.cutoffValue, audioCtx.currentTime);
      }

      if (patch.lfo.targetAmp) {
        ampLfoAmp.gain.setValueAtTime(patch.lfo.ampValue, audioCtx.currentTime);
      }
    }

    // VCO PITCH KNOBS
    [1, 2, 3].forEach(function(oscNumber) {
      if (VS.activeKnob.element.id == `vco${oscNumber}_pitch`) {
        midiValue = $(VS.activeKnob.element).data('midi');
        if (midiValue == undefined) { return; }

        patch[`setvco${oscNumber}_pitch`](midiValue);

        if (osc[oscNumber] !== null) {
          osc[oscNumber].detune.setValueAtTime(
            patch.vco[oscNumber].detune, audioCtx.currentTime
          );
        }
      }
    });

    // VOLUME
    if (VS.activeKnob.element.id == 'volume') {
      midiValue = $(VS.activeKnob.element).data('midi');
      if (midiValue == undefined) { return; }

      patch.setvolume(midiValue);
      masterAmp.gain.setValueAtTime(patch.volume, audioCtx.currentTime);
    }
  });

  const toggleVcoAmp = function(oscNumber) {
    if (patch.vco[oscNumber].amp == defaultVcoAmp) {
      patch.vco[oscNumber].amp = 0;
    } else {
      patch.vco[oscNumber].amp = defaultVcoAmp;
    }
    oscMuteAmps[oscNumber].gain.setValueAtTime(
      patch.vco[oscNumber].amp, audioCtx.currentTime
    );
  };

  // VCO MUTE BUTTONS
  [1, 2, 3].forEach(function(oscNumber) {
    $(`#vco${oscNumber}_active_button`).on('click tap', function(){
      toggleVcoAmp(oscNumber);
    });
  });

  // LFO TARGET AMP
  $('label[for="patch_lfo_target_amp"]').on('click tap', function() {
    patch.lfo.targetAmp = !patch.lfo.targetAmp;
    setAmpLfoAmpGain();
  });

  // LFO TARGET PITCH
  $('label[for="patch_lfo_target_pitch"]').on('click tap', function() {
    patch.lfo.targetPitch = !patch.lfo.targetPitch;
    setAmpLfoPitchGain();
  });

  // LFO TARGET CUTOFF
  $('label[for="patch_lfo_target_cutoff"]').on('click tap', function() {
    patch.lfo.targetCutoff = !patch.lfo.targetCutoff;
    setAmpLfoCutoffGain();
  });

  // LFO WAVE
  $('label[for="patch_lfo_wave"]').on('click tap', function() {
     if (patch.lfo.shape == 'triangle') {
       patch.setlfo_wave('square');
     } else {
       patch.setlfo_wave('triangle');
    }
    oscLfo.type = patch.lfo.shape;
  });

  const toggleVcoWave = function(osc, vco) {
     if (vco.shape == 'sawtooth') {
       vco.shape = 'square';
     } else {
       vco.shape = 'sawtooth';
     }
     if (osc !== null) {
       osc.type = vco.shape;
     }
  };

  // VCO WAVE
  [1, 2, 3].forEach(function(oscNumber){
    $(`label[for="patch_vco${oscNumber}_wave"]`).on('click tap', function() {
      toggleVcoWave(osc[oscNumber], patch.vco[oscNumber]);
    });
  });

  $('label[for="patch_sustain_on"]').on('click tap', function() {
    patch.sustainOn = !patch.sustainOn;
  });

  $('label[for="patch_amp_eg_on"]').on('click tap', function() {
    patch.ampEgOn = !patch.ampEgOn;
  });

  // MOBILE OCTAVE UP
  $('#octave-up').on('click tap', function(){
    if (patch.octave < 9) {
      patch.octave += 1;
    }
    changeOctave();
  });

  // MOBILE OCTAVE DOWN
  $('#octave-down').on('click tap', function(){
    if (patch.octave > -1) {
      patch.octave -= 1;
    }
    changeOctave();
  });

  // MOBILE KEY
  $('.mobile-control.key').on('mousedown touchstart', function(e) {
    notePlaying = $(this).data('keycode');

    keyboardDown();
  });

  $('.mobile-control.key').on('mouseup touchend mouseleave', function() {
    keysDown = keysDown.filter(key => key !== $(this).data('keycode'));

    keyboardUp();
  });

  <% end %>

  // TOOLTIPS
  const itemsComingSoon = [
    'label[for="patch_vco_group_one"]',
    'label[for="patch_vco_group_two"]'
  ];

  itemsComingSoon.forEach(function(selector) {
    $(selector).mouseenter(function() {
      if (VS.dragging) { return; }
      $('.cooltip').text("Coming soon!");
      $('.cooltip').show();
    });
  });

  itemsComingSoon.forEach(function(selector) {
    $(selector).mouseleave(function() {
      $('.cooltip').hide();
    });
  });

  $('#octave').mouseenter(function() {
    $('.cooltip').text("Press 'Z' or 'X' to change octaves");
    $('.cooltip').show();
  });

  $('#octave').mouseleave(function() {
    $('.cooltip').hide();
  });

  $('#toggle-mobile').on('click tap', function(e) {
    e.preventDefault();
    $('#mobile-keyboard').removeClass('hidden');
    $('#back-to-desktop').removeClass('hidden');
    $('#desktop-instructions').hide();
  })

  $('#back-to-desktop a').on('click tap', function(e) {
    e.preventDefault();
    $('#mobile-keyboard').addClass('hidden');
    $('#back-to-desktop').addClass('hidden');
    $('#desktop-instructions').show();
  })
};
